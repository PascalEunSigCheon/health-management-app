<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Health Manager - Simple Demo</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --muted: #6b7280;
      --text: #e5e7eb;
      --accent: #22c55e;
      --danger: #ef4444;
      --focus: #60a5fa;
      --card: #0b1220;
      --border: #1f2937;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1000px 500px at 10% 10%, #0b1220 10%, transparent 60%),
                  radial-gradient(800px 400px at 90% 0%, #0b1220 10%, transparent 60%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .container {
      width: 100%;
      max-width: 960px;
    }

    .card {
      background: linear-gradient(180deg, var(--panel), rgba(17,24,39,0.6));
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }

    h1 {
      margin: 0 0 12px 0;
      font-size: 22px;
      font-weight: 700;
    }

    .muted { color: var(--muted); }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    @media (min-width: 900px) {
      .grid-2 { grid-template-columns: 1fr 1fr; }
    }

    label { font-size: 13px; color: var(--muted); }
    input[type="text"], select, textarea {
      width: 100%;
      color: var(--text);
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
      outline: none;
    }
    input[type="text"]:focus, select:focus, textarea:focus { border-color: var(--focus); box-shadow: 0 0 0 3px rgba(96,165,250,0.2); }
    textarea { resize: vertical; min-height: 80px; }

    .row { display: flex; gap: 10px; align-items: center; }
    .row > * { flex: 1; }

    .btn {
      appearance: none;
      border: none;
      background: var(--accent);
      color: #04110a;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 6px 20px rgba(34,197,94,0.25);
    }
    .btn:hover:not(:disabled) { transform: translateY(-1px); }
    .btn:active:not(:disabled) { transform: translateY(0); }
    .btn:disabled { 
      opacity: 0.6; 
      cursor: not-allowed; 
      transform: none !important;
    }
    .btn.secondary { background: #1f2937; color: var(--text); box-shadow: none; border: 1px solid var(--border); }
    .btn.danger { background: var(--danger); color: white; box-shadow: 0 6px 20px rgba(239,68,68,0.25); }

    .toolbar { display: flex; gap: 10px; align-items: center; justify-content: space-between; margin-bottom: 16px; }
    .pill { background: #0b1220; border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px; font-size: 12px; color: var(--muted); }

    .list {
      display: grid;
      gap: 10px;
    }
    .item {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .item-title { font-weight: 700; }
    .item-meta { font-size: 12px; color: var(--muted); }
    .item-actions { display: flex; gap: 8px; }

    .hidden { display: none !important; }

    .footer { margin-top: 18px; text-align: center; font-size: 12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="container">
    <div class="card" id="authCard">
      <h1>Health Manager</h1>
      <div class="muted">Simple demo: sign in as patient, doctor, or admin</div>
      <div style="height: 12px"></div>
      <form id="signInForm">
        <div class="grid">
          <div>
            <label for="email">Email</label>
            <input id="email" type="email" required placeholder="you@example.com" autocomplete="email" />
          </div>
          <div>
            <label for="password">Password</label>
            <input id="password" type="password" required placeholder="••••••••" autocomplete="current-password" />
          </div>
        </div>
        <div style="height: 12px"></div>
        <div class="row">
          <button class="btn" type="submit" id="signInBtn">Sign in</button>
        </div>
        <div style="height: 8px"></div>
        <div id="verificationCodeSection" class="hidden">
          <div class="muted" style="margin-bottom: 8px;">Enter verification code sent to your email</div>
          <div class="grid">
            <div>
              <label for="verificationCode">Verification Code</label>
              <input id="verificationCode" type="text" placeholder="Enter code" />
            </div>
          </div>
          <div style="height: 12px"></div>
          <div class="row">
            <button class="btn secondary" type="button" id="verifyBtn">Verify</button>
            <button class="btn secondary" type="button" id="resendCodeBtn">Resend Code</button>
          </div>
        </div>
      </form>
      <div class="footer">No account yet? <a href="./signup.html">Create one</a></div>
    </div>

    <div class="card hidden" id="appCard">
      <div class="toolbar">
        <div>
          <div class="pill" id="currentUserPill">Signed in</div>
        </div>
        <div class="row" style="justify-content: flex-end; gap: 8px; flex: none;">
          <button class="btn secondary" id="switchRoleBtn" title="Switch role">Switch</button>
          <button class="btn danger" id="signOutBtn">Sign out</button>
        </div>
      </div>

      <div class="grid grid-2">
        <section>
          <h1>Upload Document</h1>
          <div class="muted">Files are kept in-memory for this session only. Metadata is saved.</div>
          <div style="height: 10px"></div>
          <form id="uploadForm">
            <div class="grid">
              <div>
                <label for="fileInput">Choose file</label>
                <input id="fileInput" type="file" />
              </div>
              <div>
                <label for="docNotes">Notes</label>
                <textarea id="docNotes" placeholder="Optional notes about this document"></textarea>
              </div>
            </div>
            <div style="height: 12px"></div>
            <div class="row">
              <button class="btn" type="submit">Upload</button>
            </div>
          </form>
        </section>

        <section>
          <h1>My Info</h1>
          <div class="muted">Update a short note on your profile</div>
          <div style="height: 10px"></div>
          <form id="profileForm">
            <div>
              <label for="profileNote">Profile note</label>
              <textarea id="profileNote" placeholder="e.g., Allergic to penicillin"></textarea>
            </div>
            <div style="height: 12px"></div>
            <div class="row">
              <button class="btn secondary" type="submit">Save note</button>
            </div>
          </form>
        </section>
      </div>

      <div style="height: 16px"></div>

      <section id="patientHealthSection" class="hidden">
        <h1>Health Info (Patient)</h1>
        <div class="muted">Stored locally. Units: height in cm, weight in kg.</div>
        <div style="height: 10px"></div>
        <form id="healthForm">
          <div class="grid grid-2">
            <div>
              <label for="heightCm">Height (cm)</label>
              <input id="heightCm" type="text" inputmode="decimal" placeholder="e.g., 170" />
            </div>
            <div>
              <label for="weightKg">Weight (kg)</label>
              <input id="weightKg" type="text" inputmode="decimal" placeholder="e.g., 65" />
            </div>
            <div>
              <label for="bloodType">Blood type</label>
              <select id="bloodType">
                <option value="">Select</option>
                <option>O+</option>
                <option>O-</option>
                <option>A+</option>
                <option>A-</option>
                <option>B+</option>
                <option>B-</option>
                <option>AB+</option>
                <option>AB-</option>
              </select>
            </div>
            <div>
              <label for="age">Age</label>
              <input id="age" type="text" inputmode="numeric" placeholder="e.g., 34" />
            </div>
          </div>
          <div style="height: 10px"></div>
          <div>
            <label for="allergies">Allergies</label>
            <textarea id="allergies" placeholder="e.g., Peanuts, penicillin"></textarea>
          </div>
          <div style="height: 10px"></div>
          <div>
            <label for="conditions">Conditions</label>
            <textarea id="conditions" placeholder="e.g., Asthma"></textarea>
          </div>
          <div style="height: 12px"></div>
          <div class="row" style="align-items: center;">
            <button class="btn secondary" type="submit">Save health info</button>
            <div class="pill" id="bmiPill">BMI: —</div>
          </div>
        </form>
      </section>

      <section>
        <h1 id="listTitle">Documents</h1>
        <div class="list" id="docList"></div>
      </section>

      <div class="footer">Demo only. No backend. For real apps, use a secure server and storage.</div>
    </div>
  </div>

  <!-- AWS Cognito SDK -->
  <script src="https://unpkg.com/amazon-cognito-identity-js@6.3.12/dist/amazon-cognito-identity.min.js"></script>
  
  <script>
    // AWS Cognito Configuration - Update these with your Cognito User Pool details
    const COGNITO_CONFIG = {
      UserPoolId: 'us-east-1_J6s1BPTHx', // e.g., 'us-east-1_xxxxxxxxx'
      ClientId: '76dlunfcl962e5eoog063ae8fq', // e.g., 'xxxxxxxxxxxxxxxxxxxxxxxxxx'
      ClientSecret: '11r13l9l5krdp4veumv94jtpm8c6idoef977n26i148rklvo13d5', // Get this from Cognito App Client settings
      Region: 'us-east-1' // e.g., 'us-east-1'
    };

    // Initialize Cognito User Pool
    const poolData = {
      UserPoolId: COGNITO_CONFIG.UserPoolId,
      ClientId: COGNITO_CONFIG.ClientId
    };
    const userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);

    // Calculate SECRET_HASH for Cognito requests (required when App Client has a secret)
    async function calculateSecretHash(username) {
      if (!COGNITO_CONFIG.ClientSecret) {
        return null; // No secret hash needed if no client secret
      }
      
      const message = username + COGNITO_CONFIG.ClientId;
      const encoder = new TextEncoder();
      const keyData = encoder.encode(COGNITO_CONFIG.ClientSecret);
      const messageData = encoder.encode(message);
      
      const key = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
      );
      
      const signature = await crypto.subtle.sign('HMAC', key, messageData);
      const hashArray = Array.from(new Uint8Array(signature));
      return btoa(String.fromCharCode(...hashArray));
    }

    // API Configuration
    const API_BASE_URL = 'https://x4rdxhj5kg.execute-api.eu-west-3.amazonaws.com/prod';
    const API_ENDPOINTS = {
      patientInfo: '/registration'
    };

    const storageKeys = Object.freeze({
      currentUser: 'hm.currentUser',
      users: 'hm.users',
      documents: 'hm.documents',
      pendingHealthData: 'hm.pendingHealthData'
    });

    const inMemoryFiles = new Map();

    function getUsers() {
      const raw = localStorage.getItem(storageKeys.users);
      return raw ? JSON.parse(raw) : [];
    }
    function setUsers(users) {
      localStorage.setItem(storageKeys.users, JSON.stringify(users));
    }
    function getDocuments() {
      const raw = localStorage.getItem(storageKeys.documents);
      return raw ? JSON.parse(raw) : [];
    }
    function setDocuments(docs) {
      localStorage.setItem(storageKeys.documents, JSON.stringify(docs));
    }
    function getCurrentUser() {
      const raw = localStorage.getItem(storageKeys.currentUser);
      return raw ? JSON.parse(raw) : null;
    }
    function setCurrentUser(user) {
      localStorage.setItem(storageKeys.currentUser, JSON.stringify(user));
    }

    // Get Cognito user attributes
    async function getCognitoUserAttributes(cognitoUser) {
      return new Promise((resolve, reject) => {
        cognitoUser.getUserAttributes((err, attributes) => {
          if (err) {
            reject(err);
            return;
          }
          const attrs = {};
          attributes.forEach(attr => {
            attrs[attr.Name] = attr.Value;
          });
          resolve(attrs);
        });
      });
    }

    // Sync pending health data after sign-in
    async function syncPendingHealthData(cognitoUser) {
      const pendingData = localStorage.getItem(storageKeys.pendingHealthData);
      if (!pendingData) return;

      try {
        const healthData = JSON.parse(pendingData);
        const session = await new Promise((resolve, reject) => {
          cognitoUser.getSession((err, session) => {
            if (err) reject(err);
            else resolve(session);
          });
        });

        if (session.isValid()) {
          const idToken = session.getIdToken().getJwtToken();
          const attrs = await getCognitoUserAttributes(cognitoUser);
          
          // Get role from localStorage
          const users = getUsers();
          const existingUser = users.find(u => u.email === attrs.email);
          
          const patientData = {
            name: attrs.name || attrs.email,
            email: attrs.email,
            role: existingUser?.role || 'patient',
            health: healthData
          };

          const response = await fetch(API_BASE_URL + API_ENDPOINTS.patientInfo, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${idToken}`
            },
            body: JSON.stringify(patientData)
          });

          if (response.ok) {
            localStorage.removeItem(storageKeys.pendingHealthData);
            console.log('Pending health data synced successfully');
          }
        }
      } catch (error) {
        console.error('Error syncing pending health data:', error);
      }
    }

    // Helper function to handle authentication errors
    function handleAuthError(err, reject) {
      console.error('Authentication error:', err);
      
      let errorCode = err.code || err.name || '';
      let errorMessage = err.message || 'Unknown error';
      
      if (errorMessage.includes('NotAuthorizedException') || errorCode === 'NotAuthorizedException') {
        reject({ code: 'NotAuthorizedException', message: 'Incorrect email or password. Please check your credentials and try again.' });
      } else if (errorMessage.includes('UserNotConfirmedException') || errorCode === 'UserNotConfirmedException') {
        reject({ code: 'UserNotConfirmedException', message: 'Please verify your email first.' });
      } else if (errorMessage.includes('UserNotFoundException') || errorCode === 'UserNotFoundException') {
        reject({ code: 'UserNotFoundException', message: 'No account found with this email address.' });
      } else if (errorMessage.includes('InvalidParameterException') || errorCode === 'InvalidParameterException') {
        reject({ code: 'InvalidParameterException', message: 'Invalid parameters. Please check your email and password format.' });
      } else {
        reject({ code: errorCode, message: errorMessage, originalError: err });
      }
    }

    // SRP authentication with SECRET_HASH support
    async function authenticateWithSRPAndSecretHash(email, password, cognitoUser) {
      try {
        const secretHash = await calculateSecretHash(email);
        
        // Step 1: InitiateAuth with USER_SRP_AUTH
        const initiateAuthParams = {
          ClientId: COGNITO_CONFIG.ClientId,
          AuthFlow: 'USER_SRP_AUTH',
          AuthParameters: {
            USERNAME: email,
            SRP_A: '' // Will be calculated by SDK's AuthenticationHelper
          }
        };
        
        if (secretHash) {
          initiateAuthParams.AuthParameters.SECRET_HASH = secretHash;
        }

        // Use SDK's AuthenticationHelper for SRP calculations
        // Extract pool name from UserPoolId (format: region_poolname)
        const poolName = COGNITO_CONFIG.UserPoolId.split('_')[1];
        
        // Check if AuthenticationHelper is available
        if (typeof AmazonCognitoIdentity.AuthenticationHelper === 'undefined') {
          throw new Error('AuthenticationHelper not available. Please ensure you are using the full SDK version.');
        }
        
        const authenticationHelper = new AmazonCognitoIdentity.AuthenticationHelper(poolName);
        
        // Generate A value for SRP
        const aValue = authenticationHelper.getLargeAValue();
        initiateAuthParams.AuthParameters.SRP_A = aValue;
        const initiateResponse = await fetch(`https://cognito-idp.${COGNITO_CONFIG.Region}.amazonaws.com/`, {
          method: 'POST',
          headers: {
            'X-Amz-Target': 'AWSCognitoIdentityProviderService.InitiateAuth',
            'Content-Type': 'application/x-amz-json-1.1'
          },
          body: JSON.stringify(initiateAuthParams)
        });

        const initiateResult = await initiateResponse.json();

        if (!initiateResponse.ok) {
          const errorType = initiateResult.__type || '';
          const errorMessage = initiateResult.message || 'Authentication failed';
          throw { code: errorType, message: errorMessage };
        }

        // Step 2: Calculate password verifier and respond to challenge
        const challengeParameters = initiateResult.ChallengeParameters;
        const challengeName = initiateResult.ChallengeName;

        if (challengeName !== 'PASSWORD_VERIFIER') {
          throw { code: 'UnexpectedChallenge', message: 'Unexpected challenge: ' + challengeName };
        }

        // Calculate password verifier using SDK's helper
        const passwordVerifier = authenticationHelper.getPasswordAuthenticationKey(
          challengeParameters.USER_ID_FOR_SRP,
          password,
          challengeParameters.SRP_B,
          challengeParameters.SALT
        );

        // Format timestamp: YYYYMMDDTHHmmss
        const now = new Date();
        const timestamp = now.getUTCFullYear().toString() +
          String(now.getUTCMonth() + 1).padStart(2, '0') +
          String(now.getUTCDate()).padStart(2, '0') +
          'T' +
          String(now.getUTCHours()).padStart(2, '0') +
          String(now.getUTCMinutes()).padStart(2, '0') +
          String(now.getUTCSeconds()).padStart(2, '0') +
          'Z';
        
        const secretBlock = challengeParameters.SECRET_BLOCK;
        
        // Create message for HMAC (concatenate strings)
        const msgString = challengeParameters.USER_ID_FOR_SRP +
          challengeParameters.SECRET_BLOCK +
          timestamp;
        
        // Convert message to Uint8Array
        const encoder = new TextEncoder();
        const msg = encoder.encode(msgString);
        
        // Convert passwordVerifier (ArrayBuffer) to CryptoKey for HMAC
        const hmacKey = await crypto.subtle.importKey(
          'raw',
          passwordVerifier,
          { name: 'HMAC', hash: 'SHA-256' },
          false,
          ['sign']
        );
        
        // Calculate HMAC signature
        const signature = await crypto.subtle.sign('HMAC', hmacKey, msg);
        const signatureString = btoa(String.fromCharCode(...new Uint8Array(signature)));

        // Step 3: RespondToAuthChallenge
        const respondParams = {
          ClientId: COGNITO_CONFIG.ClientId,
          ChallengeName: 'PASSWORD_VERIFIER',
          ChallengeResponses: {
            USERNAME: challengeParameters.USERNAME,
            PASSWORD_CLAIM_SECRET_BLOCK: secretBlock,
            PASSWORD_CLAIM_SIGNATURE: signatureString,
            TIMESTAMP: timestamp
          }
        };

        if (secretHash) {
          respondParams.ChallengeResponses.SECRET_HASH = secretHash;
        }

        const respondResponse = await fetch(`https://cognito-idp.${COGNITO_CONFIG.Region}.amazonaws.com/`, {
          method: 'POST',
          headers: {
            'X-Amz-Target': 'AWSCognitoIdentityProviderService.RespondToAuthChallenge',
            'Content-Type': 'application/x-amz-json-1.1'
          },
          body: JSON.stringify(respondParams)
        });

        const respondResult = await respondResponse.json();

        if (!respondResponse.ok) {
          const errorType = respondResult.__type || '';
          const errorMessage = respondResult.message || 'Authentication failed';
          throw { code: errorType, message: errorMessage };
        }

        // Check if new password is required
        if (respondResult.ChallengeName === 'NEW_PASSWORD_REQUIRED') {
          throw new Error('New password required. Please reset your password.');
        }

        // Extract tokens
        const authenticationResult = respondResult.AuthenticationResult;
        if (!authenticationResult) {
          throw { code: 'NoTokens', message: 'No authentication tokens received' };
        }

        const idToken = authenticationResult.IdToken;
        const accessToken = authenticationResult.AccessToken;

        // Store session in CognitoUser for SDK compatibility
        const sessionData = {
          IdToken: new AmazonCognitoIdentity.CognitoIdToken({ IdToken: idToken }),
          AccessToken: new AmazonCognitoIdentity.CognitoAccessToken({ AccessToken: accessToken }),
          RefreshToken: authenticationResult.RefreshToken 
            ? new AmazonCognitoIdentity.CognitoRefreshToken({ RefreshToken: authenticationResult.RefreshToken })
            : null
        };
        
        const session = new AmazonCognitoIdentity.CognitoUserSession(sessionData);
        cognitoUser.setSignInUserSession(session);

        // Get user attributes
        const attrs = await getCognitoUserAttributes(cognitoUser);
        
        // Get role from localStorage or default to 'patient'
        let allUsers = getUsers();
        const existingUser = allUsers.find(u => u.email === attrs.email);
        
        const user = {
          id: attrs.email,
          email: attrs.email,
          name: attrs.name || attrs.email,
          role: existingUser?.role || 'patient',
          profileNote: existingUser?.profileNote || '',
          idToken,
          accessToken
        };

        // Store in localStorage
        allUsers = getUsers();
        const existingIndex = allUsers.findIndex(u => u.email === user.email);
        if (existingIndex >= 0) {
          allUsers[existingIndex] = { ...allUsers[existingIndex], ...user };
        } else {
          allUsers.push(user);
        }
        setUsers(allUsers);
        setCurrentUser(user);

        await updateUIForUser(user, cognitoUser);
      } catch (error) {
        // Handle errors from SRP authentication
        console.error('SRP authentication error:', error);
        
        // Re-throw with proper error format
        const errorType = error.code || error.__type || '';
        const errorMessage = error.message || 'Authentication failed';
        
        // Check for specific error types
        if (errorType.includes('NotAuthorizedException') || errorMessage.includes('NotAuthorizedException')) {
          throw { code: 'NotAuthorizedException', message: 'Incorrect email or password. Please check your credentials.' };
        } else if (errorType.includes('UserNotConfirmedException') || errorMessage.includes('UserNotConfirmedException')) {
          throw { code: 'UserNotConfirmedException', message: 'Please verify your email first.' };
        } else if (errorType.includes('UserNotFoundException') || errorMessage.includes('UserNotFoundException')) {
          throw { code: 'UserNotFoundException', message: 'No account found with this email address.' };
        } else {
          throw { code: errorType, message: errorMessage, originalError: error };
        }
      }
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B','KB','MB','GB','TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    async function updateUIForUser(user, cognitoUser = null) {
      const authCard = document.getElementById('authCard');
      const appCard = document.getElementById('appCard');
      const pill = document.getElementById('currentUserPill');
      const listTitle = document.getElementById('listTitle');
      const profileNote = document.getElementById('profileNote');
      const healthSection = document.getElementById('patientHealthSection');

      if (!user) {
        authCard.classList.remove('hidden');
        appCard.classList.add('hidden');
        return;
      }

      // Get user data from localStorage or API
      const users = getUsers();
      let freshUser = users.find(u => u.id === user.id || u.email === user.email);
      
      // If user from Cognito, get attributes
      if (cognitoUser && !freshUser) {
        try {
          const attrs = await getCognitoUserAttributes(cognitoUser);
          // Get role from localStorage
          const users = getUsers();
          const existingUser = users.find(u => u.email === attrs.email);
          
          freshUser = {
            id: attrs.email,
            email: attrs.email,
            name: attrs.name || attrs.email,
            role: existingUser?.role || 'patient',
            profileNote: existingUser?.profileNote || ''
          };
        } catch (err) {
          console.error('Error getting user attributes:', err);
          freshUser = user;
        }
      } else if (!freshUser) {
        freshUser = user;
      }

      // Redirect patients to the patient dashboard
      if (freshUser.role === 'patient') {
        // Sync pending health data if patient
        if (cognitoUser) {
          await syncPendingHealthData(cognitoUser);
        }
        // Redirect to patient dashboard
        window.location.href = './patient-dashboard.html';
        return;
      }

      authCard.classList.add('hidden');
      appCard.classList.remove('hidden');
      pill.textContent = freshUser.name + ' · ' + freshUser.role;

      if (freshUser.role === 'doctor') listTitle.textContent = 'All Patient Documents';
      if (freshUser.role === 'admin') listTitle.textContent = 'All Documents (Admin)';

      profileNote.value = freshUser.profileNote || '';

      if (healthSection) {
        healthSection.classList.add('hidden');
      }

      renderDocuments();
    }

    function renderDocuments() {
      const list = document.getElementById('docList');
      list.innerHTML = '';
      const user = getCurrentUser();
      if (!user) return;

      const docs = getDocuments();
      let filtered = docs;
      if (user.role === 'patient') filtered = docs.filter(d => d.ownerId === user.id);
      if (user.role === 'doctor') {
        const users = getUsers();
        const patientIds = users.filter(u => u.role === 'patient').map(u => u.id);
        filtered = docs.filter(d => patientIds.includes(d.ownerId));
      }

      if (filtered.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'muted';
        empty.textContent = 'No documents yet.';
        list.appendChild(empty);
        return;
      }

      filtered
        .sort((a, b) => b.createdAt - a.createdAt)
        .forEach(doc => {
          const owner = getUsers().find(u => u.id === doc.ownerId);
          const item = document.createElement('div');
          item.className = 'item';

          const left = document.createElement('div');
          const title = document.createElement('div');
          title.className = 'item-title';
          title.textContent = doc.fileName;

          const meta = document.createElement('div');
          meta.className = 'item-meta';
          const date = new Date(doc.createdAt).toLocaleString();
          const ownerStr = owner ? owner.name + ' (' + owner.role + ')' : 'Unknown';
          meta.textContent = ownerStr + ' · ' + formatBytes(doc.fileSize) + ' · ' + date + (doc.notes ? ' · ' + doc.notes : '');

          left.appendChild(title);
          left.appendChild(meta);

          const actions = document.createElement('div');
          actions.className = 'item-actions';

          const viewBtn = document.createElement('button');
          viewBtn.className = 'btn secondary';
          viewBtn.textContent = 'View';
          viewBtn.onclick = () => {
            const blob = inMemoryFiles.get(doc.id);
            if (!blob) { alert('File not available (only kept in-memory this session).'); return; }
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank');
            setTimeout(() => URL.revokeObjectURL(url), 10000);
          };

          const delBtn = document.createElement('button');
          delBtn.className = 'btn danger';
          delBtn.textContent = 'Delete';
          delBtn.onclick = () => {
            const confirmDel = confirm('Delete "' + doc.fileName + '"?');
            if (!confirmDel) return;
            const remaining = getDocuments().filter(d => d.id !== doc.id);
            setDocuments(remaining);
            inMemoryFiles.delete(doc.id);
            renderDocuments();
          };

          actions.appendChild(viewBtn);

          const canDelete = user.role === 'admin' || doc.ownerId === user.id;
          if (canDelete) actions.appendChild(delBtn);

          item.appendChild(left);
          item.appendChild(actions);
          list.appendChild(item);
        });
    }

    let pendingCognitoUser = null; // Store user waiting for verification

    document.getElementById('signInForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const signInBtn = document.getElementById('signInBtn');
      const originalBtnText = signInBtn.textContent;
      const email = document.getElementById('email').value.trim().toLowerCase();
      const password = document.getElementById('password').value;

      if (!email || !email.includes('@')) {
        alert('Please enter a valid email');
        return;
      }
      if (!password) {
        alert('Please enter your password');
        return;
      }

      signInBtn.disabled = true;
      signInBtn.textContent = 'Signing in...';

      const userData = {
        Username: email,
        Pool: userPool
      };
      const cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);

      try {
        // Check if client secret is configured - if so, use manual SRP with SECRET_HASH
        if (COGNITO_CONFIG.ClientSecret && COGNITO_CONFIG.ClientSecret !== 'YOUR_CLIENT_SECRET') {
          // Manual SRP authentication with SECRET_HASH support
          await authenticateWithSRPAndSecretHash(email, password, cognitoUser);

        } else {
          // Use SDK's authenticateUser method (no client secret)
          const authenticationData = {
            Username: email,
            Password: password
          };
          const authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(authenticationData);
          
          await new Promise((resolve, reject) => {
            cognitoUser.authenticateUser(authenticationDetails, {
              onSuccess: async (result) => {
                try {
                  const idToken = result.getIdToken().getJwtToken();
                  const accessToken = result.getAccessToken().getJwtToken();
                  
                  // Get user attributes
                  const attrs = await getCognitoUserAttributes(cognitoUser);
                  
                  // Get role from localStorage or default to 'patient'
                  let allUsers = getUsers();
                  const existingUser = allUsers.find(u => u.email === attrs.email);
                  
                  const user = {
                    id: attrs.email,
                    email: attrs.email,
                    name: attrs.name || attrs.email,
                    role: existingUser?.role || 'patient',
                    profileNote: existingUser?.profileNote || '',
                    idToken,
                    accessToken
                  };

                  // Store in localStorage
                  allUsers = getUsers();
                  const existingIndex = allUsers.findIndex(u => u.email === user.email);
                  if (existingIndex >= 0) {
                    allUsers[existingIndex] = { ...allUsers[existingIndex], ...user };
                  } else {
                    allUsers.push(user);
                  }
                  setUsers(allUsers);
                  setCurrentUser(user);

                  await updateUIForUser(user, cognitoUser);
                  resolve();
                } catch (err) {
                  reject(err);
                }
              },
              onFailure: (err) => {
                handleAuthError(err, reject);
              },
              newPasswordRequired: (userAttributes, requiredAttributes) => {
                reject(new Error('New password required. Please reset your password.'));
              }
            });
          });
        }
      } catch (error) {
        signInBtn.disabled = false;
        signInBtn.textContent = originalBtnText;
        
        // Log full error for debugging
        console.error('Sign in error:', error);
        console.error('Error details:', JSON.stringify(error, null, 2));
        
        let errorMessage = 'Sign in failed. ';
        let showVerificationSection = false;
        
        // Check error code and message more thoroughly
        const errorCode = error.code || error.name || '';
        const errorMsg = (error.message || '').toLowerCase();
        const fullError = JSON.stringify(error).toLowerCase();
        
        // Check for email verification requirement
        if (errorCode === 'UserNotConfirmedException' || 
            errorMsg.includes('not confirmed') || 
            errorMsg.includes('verify') ||
            fullError.includes('usernotconfirmed')) {
          errorMessage += 'Please verify your email first. Check your inbox for a verification code.';
          showVerificationSection = true;
          pendingCognitoUser = cognitoUser;
        } 
        // Check for wrong credentials
        else if (errorCode === 'NotAuthorizedException' || 
                 errorMsg.includes('not authorized') ||
                 errorMsg.includes('incorrect') ||
                 fullError.includes('notauthorized')) {
          errorMessage += 'Incorrect email or password. Please check:\n';
          errorMessage += '1. Your email address is correct\n';
          errorMessage += '2. Your password is correct\n';
          errorMessage += '3. You have verified your email (check your inbox)\n';
          errorMessage += '\nCheck the browser console (F12) for more details.';
        } 
        // Check for user not found
        else if (errorCode === 'UserNotFoundException' || 
                 errorMsg.includes('not found') ||
                 fullError.includes('usernotfound')) {
          errorMessage += 'No account found with this email address. Please sign up first.';
        } 
        // Check for invalid parameters
        else if (errorCode === 'InvalidParameterException' || 
                 errorMsg.includes('invalid parameter')) {
          errorMessage += 'Invalid email or password format. Please check your input.';
        }
        // Generic error - show actual message
        else if (error.message) {
          errorMessage += error.message;
          // Also log to console for debugging
          if (error.originalError) {
            console.error('Original error:', error.originalError);
          }
        } 
        // Unknown error
        else {
          errorMessage += 'An unexpected error occurred. ';
          errorMessage += 'Please check:\n';
          errorMessage += '1. Your email is verified (check your inbox)\n';
          errorMessage += '2. Your credentials are correct\n';
          errorMessage += '3. Check the browser console (F12) for error details';
        }
        
        // Show verification section if needed
        if (showVerificationSection) {
          document.getElementById('verificationCodeSection').classList.remove('hidden');
        }
        
        alert(errorMessage);
      }
    });

    // Handle verification code
    document.getElementById('verifyBtn').addEventListener('click', async () => {
      if (!pendingCognitoUser) {
        alert('No pending verification');
        return;
      }

      const code = document.getElementById('verificationCode').value.trim();
      if (!code) {
        alert('Please enter verification code');
        return;
      }

      try {
        // Get email from the form
        const email = document.getElementById('email').value.trim().toLowerCase();
        const secretHash = await calculateSecretHash(email);
        
        // Use direct API call for confirmRegistration to include SECRET_HASH
        const confirmParams = {
          ClientId: COGNITO_CONFIG.ClientId,
          Username: email,
          ConfirmationCode: code,
          SecretHash: secretHash
        };
        
        const response = await fetch(`https://cognito-idp.${COGNITO_CONFIG.Region}.amazonaws.com/`, {
          method: 'POST',
          headers: {
            'X-Amz-Target': 'AWSCognitoIdentityProviderService.ConfirmSignUp',
            'Content-Type': 'application/x-amz-json-1.1'
          },
          body: JSON.stringify(confirmParams)
        });
        
        const result = await response.json();
        
        if (!response.ok) {
          const errorType = result.__type || '';
          const errorMessage = result.message || 'Verification failed';
          throw { code: errorType, message: errorMessage };
        }

        alert('Email verified! Please sign in again.');
        document.getElementById('verificationCodeSection').classList.add('hidden');
        document.getElementById('verificationCode').value = '';
        pendingCognitoUser = null;
      } catch (error) {
        let errorMessage = 'Verification failed. ';
        if (error.code === 'CodeMismatchException') {
          errorMessage += 'Invalid verification code.';
        } else if (error.message) {
          errorMessage += error.message;
        }
        alert(errorMessage);
      }
    });

    // Handle resend code
    document.getElementById('resendCodeBtn').addEventListener('click', async () => {
      if (!pendingCognitoUser) {
        alert('No pending verification');
        return;
      }

      try {
        await new Promise((resolve, reject) => {
          pendingCognitoUser.resendConfirmationCode((err, result) => {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });

        alert('Verification code resent to your email');
      } catch (error) {
        alert('Failed to resend code: ' + (error.message || 'Please try again'));
      }
    });

    document.getElementById('signOutBtn').addEventListener('click', () => {
      const currentUser = getCurrentUser();
      
      // Sign out from Cognito
      if (currentUser && currentUser.email) {
        const userData = {
          Username: currentUser.email,
          Pool: userPool
        };
        const cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);
        cognitoUser.signOut();
      }

      // Clear local storage
      localStorage.removeItem(storageKeys.currentUser);
      updateUIForUser(null);
      
      // Clear form
      document.getElementById('email').value = '';
      document.getElementById('password').value = '';
      document.getElementById('verificationCode').value = '';
      document.getElementById('verificationCodeSection').classList.add('hidden');
    });

    document.getElementById('switchRoleBtn').addEventListener('click', () => {
      const user = getCurrentUser();
      if (!user) return;
      const next = user.role === 'patient' ? 'doctor' : user.role === 'doctor' ? 'admin' : 'patient';
      const users = getUsers();
      const idx = users.findIndex(u => u.id === user.id);
      if (idx >= 0) {
        users[idx].role = next;
        setUsers(users);
        setCurrentUser(users[idx]);
        updateUIForUser(users[idx]);
      }
    });

    document.getElementById('uploadForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const user = getCurrentUser();
      if (!user) { alert('Please sign in first.'); return; }
      const input = document.getElementById('fileInput');
      const notes = document.getElementById('docNotes').value.trim();
      if (!input.files || input.files.length === 0) { alert('Select a file to upload.'); return; }
      const file = input.files[0];

      const arrayBuffer = await file.arrayBuffer();
      const blob = new Blob([arrayBuffer], { type: file.type || 'application/octet-stream' });

      const doc = {
        id: crypto.randomUUID(),
        ownerId: user.id,
        fileName: file.name,
        fileSize: file.size,
        fileType: file.type,
        createdAt: Date.now(),
        notes
      };

      const docs = getDocuments();
      docs.push(doc);
      setDocuments(docs);
      inMemoryFiles.set(doc.id, blob);

      document.getElementById('fileInput').value = '';
      document.getElementById('docNotes').value = '';
      renderDocuments();
    });

    document.getElementById('profileForm').addEventListener('submit', (e) => {
      e.preventDefault();
      const user = getCurrentUser();
      if (!user) return;
      const note = document.getElementById('profileNote').value.trim();
      const users = getUsers();
      const idx = users.findIndex(u => u.id === user.id);
      if (idx >= 0) {
        users[idx].profileNote = note;
        setUsers(users);
        setCurrentUser(users[idx]);
      }
      alert('Saved');
    });

    function parseNumber(value) {
      if (typeof value !== 'string') return null;
      const v = value.replace(/,/g, '.').trim();
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function computeAndShowBmi() {
      const h = parseNumber(document.getElementById('heightCm').value);
      const w = parseNumber(document.getElementById('weightKg').value);
      const pill = document.getElementById('bmiPill');
      if (!pill) return;
      if (!h || !w || h <= 0 || w <= 0) { pill.textContent = 'BMI: —'; return; }
      const meters = h / 100;
      const bmi = w / (meters * meters);
      pill.textContent = 'BMI: ' + bmi.toFixed(1);
    }

    function prefillHealthForm(user) {
      const health = (user && user.health) || {};
      document.getElementById('heightCm').value = health.heightCm ?? '';
      document.getElementById('weightKg').value = health.weightKg ?? '';
      document.getElementById('bloodType').value = health.bloodType ?? '';
      document.getElementById('age').value = health.age ?? '';
      document.getElementById('allergies').value = health.allergies ?? '';
      document.getElementById('conditions').value = health.conditions ?? '';
      computeAndShowBmi();
    }

    ['heightCm','weightKg'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('input', computeAndShowBmi);
    });

    document.getElementById('healthForm').addEventListener('submit', (e) => {
      e.preventDefault();
      const user = getCurrentUser();
      if (!user) return;
      const heightCm = parseNumber(document.getElementById('heightCm').value);
      const weightKg = parseNumber(document.getElementById('weightKg').value);
      const bloodType = document.getElementById('bloodType').value;
      const age = parseNumber(document.getElementById('age').value);
      const allergies = document.getElementById('allergies').value.trim();
      const conditions = document.getElementById('conditions').value.trim();

      const users = getUsers();
      const idx = users.findIndex(u => u.id === user.id);
      if (idx >= 0) {
        users[idx].health = {
          heightCm: heightCm ?? null,
          weightKg: weightKg ?? null,
          bloodType: bloodType || '',
          age: age ?? null,
          allergies,
          conditions
        };
        setUsers(users);
        setCurrentUser(users[idx]);
      }
      computeAndShowBmi();
      alert('Health info saved');
    });

    window.addEventListener('storage', () => {
      // Keep multiple tabs in sync
      updateUIForUser(getCurrentUser());
    });

    // Check for existing Cognito session on page load
    async function checkCognitoSession() {
      const currentUser = userPool.getCurrentUser();
      if (currentUser) {
        try {
          const session = await new Promise((resolve, reject) => {
            currentUser.getSession((err, session) => {
              if (err) reject(err);
              else resolve(session);
            });
          });

          if (session.isValid()) {
            const idToken = session.getIdToken().getJwtToken();
            const attrs = await getCognitoUserAttributes(currentUser);
            
            // Get role from localStorage or default to 'patient'
            const users = getUsers();
            const existingUser = users.find(u => u.email === attrs.email);
            
            const user = {
              id: attrs.email,
              email: attrs.email,
              name: attrs.name || attrs.email,
              role: existingUser?.role || 'patient',
              profileNote: existingUser?.profileNote || '',
              idToken
            };

            // Update localStorage
            const existingIndex = users.findIndex(u => u.email === user.email);
            if (existingIndex >= 0) {
              users[existingIndex] = { ...users[existingIndex], ...user };
            } else {
              users.push(user);
            }
            setUsers(users);
            setCurrentUser(user);

            await updateUIForUser(user, currentUser);
            return;
          }
        } catch (err) {
          console.error('Error checking Cognito session:', err);
          // If session is invalid, sign out
          if (currentUser) {
            currentUser.signOut();
          }
        }
      }
      
      // Fallback to localStorage if no valid Cognito session
      updateUIForUser(getCurrentUser());
    }

    // Init
    checkCognitoSession();
  </script>
</body>
</html>