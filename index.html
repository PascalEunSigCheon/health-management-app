<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Health Manager - Simple Demo</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --muted: #6b7280;
      --text: #e5e7eb;
      --accent: #22c55e;
      --danger: #ef4444;
      --focus: #60a5fa;
      --card: #0b1220;
      --border: #1f2937;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1000px 500px at 10% 10%, #0b1220 10%, transparent 60%),
                  radial-gradient(800px 400px at 90% 0%, #0b1220 10%, transparent 60%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .container {
      width: 100%;
      max-width: 960px;
    }

    .card {
      background: linear-gradient(180deg, var(--panel), rgba(17,24,39,0.6));
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }

    h1 {
      margin: 0 0 12px 0;
      font-size: 22px;
      font-weight: 700;
    }

    .muted { color: var(--muted); }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    @media (min-width: 900px) {
      .grid-2 { grid-template-columns: 1fr 1fr; }
    }

    label { font-size: 13px; color: var(--muted); }
    input[type="text"], select, textarea {
      width: 100%;
      color: var(--text);
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
      outline: none;
    }
    input[type="text"]:focus, select:focus, textarea:focus { border-color: var(--focus); box-shadow: 0 0 0 3px rgba(96,165,250,0.2); }
    textarea { resize: vertical; min-height: 80px; }

    .row { display: flex; gap: 10px; align-items: center; }
    .row > * { flex: 1; }

    .btn {
      appearance: none;
      border: none;
      background: var(--accent);
      color: #04110a;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 6px 20px rgba(34,197,94,0.25);
    }
    .btn:hover:not(:disabled) { transform: translateY(-1px); }
    .btn:active:not(:disabled) { transform: translateY(0); }
    .btn:disabled { 
      opacity: 0.6; 
      cursor: not-allowed; 
      transform: none !important;
    }
    .btn.secondary { background: #1f2937; color: var(--text); box-shadow: none; border: 1px solid var(--border); }
    .btn.danger { background: var(--danger); color: white; box-shadow: 0 6px 20px rgba(239,68,68,0.25); }

    .toolbar { display: flex; gap: 10px; align-items: center; justify-content: space-between; margin-bottom: 16px; }
    .pill { background: #0b1220; border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px; font-size: 12px; color: var(--muted); }

    .list {
      display: grid;
      gap: 10px;
    }
    .item {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .item-title { font-weight: 700; }
    .item-meta { font-size: 12px; color: var(--muted); }
    .item-actions { display: flex; gap: 8px; }

    .hidden { display: none !important; }

    .footer { margin-top: 18px; text-align: center; font-size: 12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="container">
    <div class="card" id="authCard">
      <h1>Health Manager</h1>
      <div class="muted">Simple demo: sign in as patient, doctor, or admin</div>
      <div style="height: 12px"></div>
      <form id="signInForm">
        <div class="grid">
          <div>
            <label for="email">Email</label>
            <input id="email" type="email" required placeholder="you@example.com" autocomplete="email" />
          </div>
          <div>
            <label for="password">Password</label>
            <input id="password" type="password" required placeholder="••••••••" autocomplete="current-password" />
          </div>
        </div>
        <div style="height: 12px"></div>
        <div class="row">
          <button class="btn" type="submit" id="signInBtn">Sign in</button>
        </div>
        <div style="height: 8px"></div>
        <div id="verificationCodeSection" class="hidden">
          <div class="muted" style="margin-bottom: 8px;">Enter verification code sent to your email</div>
          <div class="grid">
            <div>
              <label for="verificationCode">Verification Code</label>
              <input id="verificationCode" type="text" placeholder="Enter code" />
            </div>
          </div>
          <div style="height: 12px"></div>
          <div class="row">
            <button class="btn secondary" type="button" id="verifyBtn">Verify</button>
            <button class="btn secondary" type="button" id="resendCodeBtn">Resend Code</button>
          </div>
        </div>
      </form>
      <div class="footer">No account yet? <a href="./signup.html">Create one</a></div>
    </div>

    <div class="card hidden" id="appCard">
      <div class="toolbar">
        <div>
          <div class="pill" id="currentUserPill">Signed in</div>
        </div>
        <div class="row" style="justify-content: flex-end; gap: 8px; flex: none;">
          <button class="btn secondary" id="switchRoleBtn" title="Switch role">Switch</button>
          <button class="btn danger" id="signOutBtn">Sign out</button>
        </div>
      </div>

      <div class="grid grid-2">
        <section>
          <h1>Upload Document</h1>
          <div class="muted">Files are kept in-memory for this session only. Metadata is saved.</div>
          <div style="height: 10px"></div>
          <form id="uploadForm">
            <div class="grid">
              <div>
                <label for="fileInput">Choose file</label>
                <input id="fileInput" type="file" />
              </div>
              <div>
                <label for="docNotes">Notes</label>
                <textarea id="docNotes" placeholder="Optional notes about this document"></textarea>
              </div>
            </div>
            <div style="height: 12px"></div>
            <div class="row">
              <button class="btn" type="submit">Upload</button>
            </div>
          </form>
        </section>

        <section>
          <h1>My Info</h1>
          <div class="muted">Update a short note on your profile</div>
          <div style="height: 10px"></div>
          <form id="profileForm">
            <div>
              <label for="profileNote">Profile note</label>
              <textarea id="profileNote" placeholder="e.g., Allergic to penicillin"></textarea>
            </div>
            <div style="height: 12px"></div>
            <div class="row">
              <button class="btn secondary" type="submit">Save note</button>
            </div>
          </form>
        </section>
      </div>

      <div style="height: 16px"></div>

      <section id="patientHealthSection" class="hidden">
        <h1>Health Info (Patient)</h1>
        <div class="muted">Stored locally. Units: height in cm, weight in kg.</div>
        <div style="height: 10px"></div>
        <form id="healthForm">
          <div class="grid grid-2">
            <div>
              <label for="heightCm">Height (cm)</label>
              <input id="heightCm" type="text" inputmode="decimal" placeholder="e.g., 170" />
            </div>
            <div>
              <label for="weightKg">Weight (kg)</label>
              <input id="weightKg" type="text" inputmode="decimal" placeholder="e.g., 65" />
            </div>
            <div>
              <label for="bloodType">Blood type</label>
              <select id="bloodType">
                <option value="">Select</option>
                <option>O+</option>
                <option>O-</option>
                <option>A+</option>
                <option>A-</option>
                <option>B+</option>
                <option>B-</option>
                <option>AB+</option>
                <option>AB-</option>
              </select>
            </div>
            <div>
              <label for="age">Age</label>
              <input id="age" type="text" inputmode="numeric" placeholder="e.g., 34" />
            </div>
          </div>
          <div style="height: 10px"></div>
          <div>
            <label for="allergies">Allergies</label>
            <textarea id="allergies" placeholder="e.g., Peanuts, penicillin"></textarea>
          </div>
          <div style="height: 10px"></div>
          <div>
            <label for="conditions">Conditions</label>
            <textarea id="conditions" placeholder="e.g., Asthma"></textarea>
          </div>
          <div style="height: 12px"></div>
          <div class="row" style="align-items: center;">
            <button class="btn secondary" type="submit">Save health info</button>
            <div class="pill" id="bmiPill">BMI: —</div>
          </div>
        </form>
      </section>

      <section>
        <h1 id="listTitle">Documents</h1>
        <div class="list" id="docList"></div>
      </section>

      <div class="footer">Demo only. No backend. For real apps, use a secure server and storage.</div>
    </div>
  </div>

  <!-- AWS Cognito SDK -->
  <script src="https://unpkg.com/amazon-cognito-identity-js@6.3.12/dist/amazon-cognito-identity.min.js"></script>
  
  <script>
    // AWS Cognito Configuration - Update these with your Cognito User Pool details
    const COGNITO_CONFIG = {
      UserPoolId: 'us-east-1_J6s1BPTHx', // e.g., 'us-east-1_xxxxxxxxx'
      ClientId: '76dlunfcl962e5eoog063ae8fq', // e.g., 'xxxxxxxxxxxxxxxxxxxxxxxxxx'
      ClientSecret: '11r13l9l5krdp4veumv94jtpm8c6idoef977n26i148rklvo13d5', // Get this from Cognito App Client settings
      Region: 'us-east-1' // e.g., 'us-east-1'
    };

    // Initialize Cognito User Pool
    const poolData = {
      UserPoolId: COGNITO_CONFIG.UserPoolId,
      ClientId: COGNITO_CONFIG.ClientId
    };
    const userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);

    // Calculate SECRET_HASH for Cognito requests (required when App Client has a secret)
    async function calculateSecretHash(username) {
      if (!COGNITO_CONFIG.ClientSecret) {
        return null; // No secret hash needed if no client secret
      }
      
      const message = username + COGNITO_CONFIG.ClientId;
      const encoder = new TextEncoder();
      const keyData = encoder.encode(COGNITO_CONFIG.ClientSecret);
      const messageData = encoder.encode(message);
      
      const key = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
      );
      
      const signature = await crypto.subtle.sign('HMAC', key, messageData);
      const hashArray = Array.from(new Uint8Array(signature));
      return btoa(String.fromCharCode(...hashArray));
    }

    // API Configuration
    const API_BASE_URL = 'https://x4rdxhj5kg.execute-api.eu-west-3.amazonaws.com/prod';
    const API_ENDPOINTS = {
      patientInfo: '/registration'
    };

    const storageKeys = Object.freeze({
      currentUser: 'hm.currentUser',
      users: 'hm.users',
      documents: 'hm.documents',
      pendingHealthData: 'hm.pendingHealthData'
    });

    const inMemoryFiles = new Map();

    function getUsers() {
      const raw = localStorage.getItem(storageKeys.users);
      return raw ? JSON.parse(raw) : [];
    }
    function setUsers(users) {
      localStorage.setItem(storageKeys.users, JSON.stringify(users));
    }
    function getDocuments() {
      const raw = localStorage.getItem(storageKeys.documents);
      return raw ? JSON.parse(raw) : [];
    }
    function setDocuments(docs) {
      localStorage.setItem(storageKeys.documents, JSON.stringify(docs));
    }
    function getCurrentUser() {
      const raw = localStorage.getItem(storageKeys.currentUser);
      return raw ? JSON.parse(raw) : null;
    }
    function setCurrentUser(user) {
      localStorage.setItem(storageKeys.currentUser, JSON.stringify(user));
    }

    // Get Cognito user attributes
    async function getCognitoUserAttributes(cognitoUser) {
      return new Promise((resolve, reject) => {
        cognitoUser.getUserAttributes((err, attributes) => {
          if (err) {
            reject(err);
            return;
          }
          const attrs = {};
          attributes.forEach(attr => {
            attrs[attr.Name] = attr.Value;
          });
          resolve(attrs);
        });
      });
    }

    // Sync pending health data after sign-in
    async function syncPendingHealthData(cognitoUser) {
      const pendingData = localStorage.getItem(storageKeys.pendingHealthData);
      if (!pendingData) return;

      try {
        const healthData = JSON.parse(pendingData);
        const session = await new Promise((resolve, reject) => {
          cognitoUser.getSession((err, session) => {
            if (err) reject(err);
            else resolve(session);
          });
        });

        if (session.isValid()) {
          const idToken = session.getIdToken().getJwtToken();
          const attrs = await getCognitoUserAttributes(cognitoUser);
          
          // Get role from localStorage
          const users = getUsers();
          const existingUser = users.find(u => u.email === attrs.email);
          
          const patientData = {
            name: attrs.name || attrs.email,
            email: attrs.email,
            role: existingUser?.role || 'patient',
            health: healthData
          };

          const response = await fetch(API_BASE_URL + API_ENDPOINTS.patientInfo, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${idToken}`
            },
            body: JSON.stringify(patientData)
          });

          if (response.ok) {
            localStorage.removeItem(storageKeys.pendingHealthData);
            console.log('Pending health data synced successfully');
          }
        }
      } catch (error) {
        console.error('Error syncing pending health data:', error);
      }
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B','KB','MB','GB','TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    async function updateUIForUser(user, cognitoUser = null) {
      const authCard = document.getElementById('authCard');
      const appCard = document.getElementById('appCard');
      const pill = document.getElementById('currentUserPill');
      const listTitle = document.getElementById('listTitle');
      const profileNote = document.getElementById('profileNote');
      const healthSection = document.getElementById('patientHealthSection');

      if (!user) {
        authCard.classList.remove('hidden');
        appCard.classList.add('hidden');
        return;
      }

      authCard.classList.add('hidden');
      appCard.classList.remove('hidden');
      pill.textContent = user.name + ' · ' + user.role;

      if (user.role === 'patient') listTitle.textContent = 'My Documents';
      if (user.role === 'doctor') listTitle.textContent = 'All Patient Documents';
      if (user.role === 'admin') listTitle.textContent = 'All Documents (Admin)';

      // Get user data from localStorage or API
      const users = getUsers();
      let freshUser = users.find(u => u.id === user.id || u.email === user.email);
      
      // If user from Cognito, get attributes
      if (cognitoUser && !freshUser) {
        try {
          const attrs = await getCognitoUserAttributes(cognitoUser);
          // Get role from localStorage
          const users = getUsers();
          const existingUser = users.find(u => u.email === attrs.email);
          
          freshUser = {
            id: attrs.email,
            email: attrs.email,
            name: attrs.name || attrs.email,
            role: existingUser?.role || 'patient',
            profileNote: existingUser?.profileNote || ''
          };
        } catch (err) {
          console.error('Error getting user attributes:', err);
          freshUser = user;
        }
      } else if (!freshUser) {
        freshUser = user;
      }

      profileNote.value = freshUser.profileNote || '';

      if (healthSection) {
        if (freshUser.role === 'patient') {
          healthSection.classList.remove('hidden');
          prefillHealthForm(freshUser);
        } else {
          healthSection.classList.add('hidden');
        }
      }

      // Sync pending health data if patient
      if (cognitoUser && freshUser.role === 'patient') {
        await syncPendingHealthData(cognitoUser);
      }

      renderDocuments();
    }

    function renderDocuments() {
      const list = document.getElementById('docList');
      list.innerHTML = '';
      const user = getCurrentUser();
      if (!user) return;

      const docs = getDocuments();
      let filtered = docs;
      if (user.role === 'patient') filtered = docs.filter(d => d.ownerId === user.id);
      if (user.role === 'doctor') {
        const users = getUsers();
        const patientIds = users.filter(u => u.role === 'patient').map(u => u.id);
        filtered = docs.filter(d => patientIds.includes(d.ownerId));
      }

      if (filtered.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'muted';
        empty.textContent = 'No documents yet.';
        list.appendChild(empty);
        return;
      }

      filtered
        .sort((a, b) => b.createdAt - a.createdAt)
        .forEach(doc => {
          const owner = getUsers().find(u => u.id === doc.ownerId);
          const item = document.createElement('div');
          item.className = 'item';

          const left = document.createElement('div');
          const title = document.createElement('div');
          title.className = 'item-title';
          title.textContent = doc.fileName;

          const meta = document.createElement('div');
          meta.className = 'item-meta';
          const date = new Date(doc.createdAt).toLocaleString();
          const ownerStr = owner ? owner.name + ' (' + owner.role + ')' : 'Unknown';
          meta.textContent = ownerStr + ' · ' + formatBytes(doc.fileSize) + ' · ' + date + (doc.notes ? ' · ' + doc.notes : '');

          left.appendChild(title);
          left.appendChild(meta);

          const actions = document.createElement('div');
          actions.className = 'item-actions';

          const viewBtn = document.createElement('button');
          viewBtn.className = 'btn secondary';
          viewBtn.textContent = 'View';
          viewBtn.onclick = () => {
            const blob = inMemoryFiles.get(doc.id);
            if (!blob) { alert('File not available (only kept in-memory this session).'); return; }
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank');
            setTimeout(() => URL.revokeObjectURL(url), 10000);
          };

          const delBtn = document.createElement('button');
          delBtn.className = 'btn danger';
          delBtn.textContent = 'Delete';
          delBtn.onclick = () => {
            const confirmDel = confirm('Delete "' + doc.fileName + '"?');
            if (!confirmDel) return;
            const remaining = getDocuments().filter(d => d.id !== doc.id);
            setDocuments(remaining);
            inMemoryFiles.delete(doc.id);
            renderDocuments();
          };

          actions.appendChild(viewBtn);

          const canDelete = user.role === 'admin' || doc.ownerId === user.id;
          if (canDelete) actions.appendChild(delBtn);

          item.appendChild(left);
          item.appendChild(actions);
          list.appendChild(item);
        });
    }

    let pendingCognitoUser = null; // Store user waiting for verification

    document.getElementById('signInForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const signInBtn = document.getElementById('signInBtn');
      const originalBtnText = signInBtn.textContent;
      const email = document.getElementById('email').value.trim().toLowerCase();
      const password = document.getElementById('password').value;

      if (!email || !email.includes('@')) {
        alert('Please enter a valid email');
        return;
      }
      if (!password) {
        alert('Please enter your password');
        return;
      }

      signInBtn.disabled = true;
      signInBtn.textContent = 'Signing in...';

      // Calculate SECRET_HASH for authentication
      const secretHash = await calculateSecretHash(email);
      
      const authenticationData = {
        Username: email,
        Password: password
      };
      
      // Note: The amazon-cognito-identity-js SDK doesn't directly support SECRET_HASH
      // We'll need to use direct API calls for authentication if client secret is required
      const authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(authenticationData);
      const userData = {
        Username: email,
        Pool: userPool
      };
      const cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);

      try {
        // If client secret is configured, use direct API call for authentication
        if (COGNITO_CONFIG.ClientSecret && COGNITO_CONFIG.ClientSecret !== 'YOUR_CLIENT_SECRET') {
          // Use direct API call for InitiateAuth with SECRET_HASH
          const authParams = {
            ClientId: COGNITO_CONFIG.ClientId,
            AuthFlow: 'USER_PASSWORD_AUTH',
            AuthParameters: {
              USERNAME: email,
              PASSWORD: password,
              SECRET_HASH: secretHash
            }
          };
          
          const response = await fetch(`https://cognito-idp.${COGNITO_CONFIG.Region}.amazonaws.com/`, {
            method: 'POST',
            headers: {
              'X-Amz-Target': 'AWSCognitoIdentityProviderService.InitiateAuth',
              'Content-Type': 'application/x-amz-json-1.1'
            },
            body: JSON.stringify(authParams)
          });
          
          const authResult = await response.json();
          
          if (!response.ok) {
            const errorType = authResult.__type || '';
            const errorMessage = authResult.message || 'Sign in failed';
            
            if (errorType.includes('NotAuthorizedException')) {
              throw { code: 'NotAuthorizedException', message: 'Incorrect email or password.' };
            } else if (errorType.includes('UserNotConfirmedException')) {
              throw { code: 'UserNotConfirmedException', message: 'Please verify your email first.' };
            } else {
              throw { code: errorType, message: errorMessage };
            }
          }
          
          // Extract tokens from response
          const accessToken = authResult.AuthenticationResult.AccessToken;
          const idToken = authResult.AuthenticationResult.IdToken;
          
          // Get user attributes using GetUser API
          const getUserParams = {
            AccessToken: accessToken
          };
          
          const getUserResponse = await fetch(`https://cognito-idp.${COGNITO_CONFIG.Region}.amazonaws.com/`, {
            method: 'POST',
            headers: {
              'X-Amz-Target': 'AWSCognitoIdentityProviderService.GetUser',
              'Content-Type': 'application/x-amz-json-1.1'
            },
            body: JSON.stringify(getUserParams)
          });
          
          const getUserResult = await getUserResponse.json();
          
          // Extract attributes
          const attrs = {};
          if (getUserResult.UserAttributes) {
            getUserResult.UserAttributes.forEach(attr => {
              attrs[attr.Name] = attr.Value;
            });
          }
          
          // Get role from localStorage or default to 'patient'
          let allUsers = getUsers();
          const existingUser = allUsers.find(u => u.email === (attrs.email || email));
          
          const user = {
            id: attrs.email || email,
            email: attrs.email || email,
            name: attrs.name || email,
            role: existingUser?.role || 'patient', // Get role from localStorage
            profileNote: existingUser?.profileNote || '',
            idToken,
            accessToken
          };
          
          // Store in localStorage
          allUsers = getUsers();
          const existingIndex = allUsers.findIndex(u => u.email === user.email);
          if (existingIndex >= 0) {
            allUsers[existingIndex] = { ...allUsers[existingIndex], ...user };
          } else {
            allUsers.push(user);
          }
          setUsers(allUsers);
          setCurrentUser(user);
          
          await updateUIForUser(user, cognitoUser);
          return;
        }
        
        // Fallback to SDK method if no client secret
        await new Promise((resolve, reject) => {
          cognitoUser.authenticateUser(authenticationDetails, {
            onSuccess: async (result) => {
              try {
                const idToken = result.getIdToken().getJwtToken();
                const accessToken = result.getAccessToken().getJwtToken();
                
                // Get user attributes
                const attrs = await getCognitoUserAttributes(cognitoUser);
                
                // Get role from localStorage or default to 'patient'
                let allUsers = getUsers();
                const existingUser = allUsers.find(u => u.email === attrs.email);
                
                const user = {
                  id: attrs.email,
                  email: attrs.email,
                  name: attrs.name || attrs.email,
                  role: existingUser?.role || 'patient',
                  profileNote: existingUser?.profileNote || '',
                  idToken,
                  accessToken
                };

                // Store in localStorage
                allUsers = getUsers();
                const existingIndex = allUsers.findIndex(u => u.email === user.email);
                if (existingIndex >= 0) {
                  allUsers[existingIndex] = { ...allUsers[existingIndex], ...user };
                } else {
                  allUsers.push(user);
                }
                setUsers(allUsers);
                setCurrentUser(user);

                await updateUIForUser(user, cognitoUser);
                resolve();
              } catch (err) {
                reject(err);
              }
            },
            onFailure: (err) => {
              reject(err);
            },
            newPasswordRequired: (userAttributes, requiredAttributes) => {
              // Handle new password requirement
              reject(new Error('New password required. Please reset your password.'));
            }
          });
        });
      } catch (error) {
        signInBtn.disabled = false;
        signInBtn.textContent = originalBtnText;
        
        let errorMessage = 'Sign in failed. ';
        if (error.code === 'NotAuthorizedException') {
          errorMessage += 'Incorrect email or password.';
        } else if (error.code === 'UserNotConfirmedException') {
          errorMessage += 'Please verify your email first.';
          // Show verification code section
          pendingCognitoUser = cognitoUser;
          document.getElementById('verificationCodeSection').classList.remove('hidden');
        } else if (error.message) {
          errorMessage += error.message;
        } else {
          errorMessage += 'Please try again.';
        }
        alert(errorMessage);
      }
    });

    // Handle verification code
    document.getElementById('verifyBtn').addEventListener('click', async () => {
      if (!pendingCognitoUser) {
        alert('No pending verification');
        return;
      }

      const code = document.getElementById('verificationCode').value.trim();
      if (!code) {
        alert('Please enter verification code');
        return;
      }

      try {
        // Get email from the form
        const email = document.getElementById('email').value.trim().toLowerCase();
        const secretHash = await calculateSecretHash(email);
        
        // Use direct API call for confirmRegistration to include SECRET_HASH
        const confirmParams = {
          ClientId: COGNITO_CONFIG.ClientId,
          Username: email,
          ConfirmationCode: code,
          SecretHash: secretHash
        };
        
        const response = await fetch(`https://cognito-idp.${COGNITO_CONFIG.Region}.amazonaws.com/`, {
          method: 'POST',
          headers: {
            'X-Amz-Target': 'AWSCognitoIdentityProviderService.ConfirmSignUp',
            'Content-Type': 'application/x-amz-json-1.1'
          },
          body: JSON.stringify(confirmParams)
        });
        
        const result = await response.json();
        
        if (!response.ok) {
          const errorType = result.__type || '';
          const errorMessage = result.message || 'Verification failed';
          throw { code: errorType, message: errorMessage };
        }

        alert('Email verified! Please sign in again.');
        document.getElementById('verificationCodeSection').classList.add('hidden');
        document.getElementById('verificationCode').value = '';
        pendingCognitoUser = null;
      } catch (error) {
        let errorMessage = 'Verification failed. ';
        if (error.code === 'CodeMismatchException') {
          errorMessage += 'Invalid verification code.';
        } else if (error.message) {
          errorMessage += error.message;
        }
        alert(errorMessage);
      }
    });

    // Handle resend code
    document.getElementById('resendCodeBtn').addEventListener('click', async () => {
      if (!pendingCognitoUser) {
        alert('No pending verification');
        return;
      }

      try {
        await new Promise((resolve, reject) => {
          pendingCognitoUser.resendConfirmationCode((err, result) => {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });

        alert('Verification code resent to your email');
      } catch (error) {
        alert('Failed to resend code: ' + (error.message || 'Please try again'));
      }
    });

    document.getElementById('signOutBtn').addEventListener('click', () => {
      const currentUser = getCurrentUser();
      
      // Sign out from Cognito
      if (currentUser && currentUser.email) {
        const userData = {
          Username: currentUser.email,
          Pool: userPool
        };
        const cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);
        cognitoUser.signOut();
      }

      // Clear local storage
      localStorage.removeItem(storageKeys.currentUser);
      updateUIForUser(null);
      
      // Clear form
      document.getElementById('email').value = '';
      document.getElementById('password').value = '';
      document.getElementById('verificationCode').value = '';
      document.getElementById('verificationCodeSection').classList.add('hidden');
    });

    document.getElementById('switchRoleBtn').addEventListener('click', () => {
      const user = getCurrentUser();
      if (!user) return;
      const next = user.role === 'patient' ? 'doctor' : user.role === 'doctor' ? 'admin' : 'patient';
      const users = getUsers();
      const idx = users.findIndex(u => u.id === user.id);
      if (idx >= 0) {
        users[idx].role = next;
        setUsers(users);
        setCurrentUser(users[idx]);
        updateUIForUser(users[idx]);
      }
    });

    document.getElementById('uploadForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const user = getCurrentUser();
      if (!user) { alert('Please sign in first.'); return; }
      const input = document.getElementById('fileInput');
      const notes = document.getElementById('docNotes').value.trim();
      if (!input.files || input.files.length === 0) { alert('Select a file to upload.'); return; }
      const file = input.files[0];

      const arrayBuffer = await file.arrayBuffer();
      const blob = new Blob([arrayBuffer], { type: file.type || 'application/octet-stream' });

      const doc = {
        id: crypto.randomUUID(),
        ownerId: user.id,
        fileName: file.name,
        fileSize: file.size,
        fileType: file.type,
        createdAt: Date.now(),
        notes
      };

      const docs = getDocuments();
      docs.push(doc);
      setDocuments(docs);
      inMemoryFiles.set(doc.id, blob);

      document.getElementById('fileInput').value = '';
      document.getElementById('docNotes').value = '';
      renderDocuments();
    });

    document.getElementById('profileForm').addEventListener('submit', (e) => {
      e.preventDefault();
      const user = getCurrentUser();
      if (!user) return;
      const note = document.getElementById('profileNote').value.trim();
      const users = getUsers();
      const idx = users.findIndex(u => u.id === user.id);
      if (idx >= 0) {
        users[idx].profileNote = note;
        setUsers(users);
        setCurrentUser(users[idx]);
      }
      alert('Saved');
    });

    function parseNumber(value) {
      if (typeof value !== 'string') return null;
      const v = value.replace(/,/g, '.').trim();
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function computeAndShowBmi() {
      const h = parseNumber(document.getElementById('heightCm').value);
      const w = parseNumber(document.getElementById('weightKg').value);
      const pill = document.getElementById('bmiPill');
      if (!pill) return;
      if (!h || !w || h <= 0 || w <= 0) { pill.textContent = 'BMI: —'; return; }
      const meters = h / 100;
      const bmi = w / (meters * meters);
      pill.textContent = 'BMI: ' + bmi.toFixed(1);
    }

    function prefillHealthForm(user) {
      const health = (user && user.health) || {};
      document.getElementById('heightCm').value = health.heightCm ?? '';
      document.getElementById('weightKg').value = health.weightKg ?? '';
      document.getElementById('bloodType').value = health.bloodType ?? '';
      document.getElementById('age').value = health.age ?? '';
      document.getElementById('allergies').value = health.allergies ?? '';
      document.getElementById('conditions').value = health.conditions ?? '';
      computeAndShowBmi();
    }

    ['heightCm','weightKg'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('input', computeAndShowBmi);
    });

    document.getElementById('healthForm').addEventListener('submit', (e) => {
      e.preventDefault();
      const user = getCurrentUser();
      if (!user) return;
      const heightCm = parseNumber(document.getElementById('heightCm').value);
      const weightKg = parseNumber(document.getElementById('weightKg').value);
      const bloodType = document.getElementById('bloodType').value;
      const age = parseNumber(document.getElementById('age').value);
      const allergies = document.getElementById('allergies').value.trim();
      const conditions = document.getElementById('conditions').value.trim();

      const users = getUsers();
      const idx = users.findIndex(u => u.id === user.id);
      if (idx >= 0) {
        users[idx].health = {
          heightCm: heightCm ?? null,
          weightKg: weightKg ?? null,
          bloodType: bloodType || '',
          age: age ?? null,
          allergies,
          conditions
        };
        setUsers(users);
        setCurrentUser(users[idx]);
      }
      computeAndShowBmi();
      alert('Health info saved');
    });

    window.addEventListener('storage', () => {
      // Keep multiple tabs in sync
      updateUIForUser(getCurrentUser());
    });

    // Check for existing Cognito session on page load
    async function checkCognitoSession() {
      const currentUser = userPool.getCurrentUser();
      if (currentUser) {
        try {
          const session = await new Promise((resolve, reject) => {
            currentUser.getSession((err, session) => {
              if (err) reject(err);
              else resolve(session);
            });
          });

          if (session.isValid()) {
            const idToken = session.getIdToken().getJwtToken();
            const attrs = await getCognitoUserAttributes(currentUser);
            
            // Get role from localStorage or default to 'patient'
            const users = getUsers();
            const existingUser = users.find(u => u.email === attrs.email);
            
            const user = {
              id: attrs.email,
              email: attrs.email,
              name: attrs.name || attrs.email,
              role: existingUser?.role || 'patient',
              profileNote: existingUser?.profileNote || '',
              idToken
            };

            // Update localStorage
            const existingIndex = users.findIndex(u => u.email === user.email);
            if (existingIndex >= 0) {
              users[existingIndex] = { ...users[existingIndex], ...user };
            } else {
              users.push(user);
            }
            setUsers(users);
            setCurrentUser(user);

            await updateUIForUser(user, currentUser);
            return;
          }
        } catch (err) {
          console.error('Error checking Cognito session:', err);
          // If session is invalid, sign out
          if (currentUser) {
            currentUser.signOut();
          }
        }
      }
      
      // Fallback to localStorage if no valid Cognito session
      updateUIForUser(getCurrentUser());
    }

    // Init
    checkCognitoSession();
  </script>
</body>
</html>